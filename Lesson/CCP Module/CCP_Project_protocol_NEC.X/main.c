/*
 Протокол NEC используетсяя в пультах 
 * дистанционного управления 
 * для контроля и регулировки систем
 */
#include "Main.h"
//------------------------------------
unsigned char lock=0;
unsigned int n=0,i=0;
unsigned int result[40]={0};
unsigned char rc_code=0,rc_addr=0,rc_code_old=0,rc_addr_old=0;

//------------------------------------

void interrupt isr(void)
{
    if(TMR1IE && TMR1IF)        //проверяем произошло ли прерывания по переполнению таймера
    {
        TMR1=0;     //сбрасываем счетчик
        TMR1IF=0;   //сбрасывам флаг прерывания
        lock=0;     //устанавливаем блок. переменную в 0
        n=0;        //счетчик в 0
    }
    if(CCP1IF)                  //проверяем произошло ли прерывание модуля CCP по захвату
    {
        TMR1=0;//сбрасываем счетчик
        CCP1IE=0;//запрещаем прерывания
        CCP1IF=0;//збрасываем флаг прерывания
        if(!lock) //проверяем блокир. переменную
        {
        result[n]=CCPR1;    //сохраняем результат в буффер
        n++;                //прибавляем счетчик
        if(n>33)
        {
          rc_code=0;//переменная для хранения передаваемых данных
          rc_addr=0;//переменная для хранения передаваемого адреса
          for(i=0;i<8;i++)  //i переменная для счета битов
          {
 //В теле цикла мы считаем биты адреса и кода команды и запишем их в соответствующие переменные
              /*
               Мы записываем значение бита в самый старший бит переменных, а
               *  затем в следующем цикле сдвигаем их вправо, так и набирается у нас байт. 
               * Число 240 выбрано потому, что при счёте до 240 мы приблизительно получаем 
               * период около 240×8 = 1920, что находится примерно в середине между периодом нуля 
               * (1,125 милисекунды) и периодом 1 (2,25 милисекунды). Поэтому если мы насчитаем 
               * больше 240, то значит это единица и мы её запишем в соответствующий бит, а если 
               * не досчитаем, то ничего не запишем и там останется 0.
               */
              rc_code>>=1;
              rc_addr>>=1;
              if(result[i+18]>240) rc_code|=0x80;
              if(result[i+2]>240)  rc_addr|=0x80;
              
          }
          n=0;//сбрасываем счетчик
          lock=1;//устанавливаем блокировку
          
        }
        }
    CCP1IE=1;//вкл. разрешения прерывания по CCP модулю
    }
    
}


void main(void) {
    
    char str1[21];
    TRISC2=1;
    CCP1IE=1;//вкл. прерывания модуля CCP1
    CCP1CON=0x04;//настраиваем на режим захвата по спадающему
    CCP1IF=0;       //сбрасываем флаг прерывания модуля CCP
    
    //------------Устанавливаем предделитель на 8--------------
    T1CKPS0=1;
    T1CKPS1=1;
    //-----------------------
    
    TMR1CS=0;       //устанавливаем внутренний источник тактирования
    TMR1IE=1;       //вкл. прерывания по переполению
    
    PEIE=1;         //вкл. прерывания по переферии
    TMR1ON=1;       //вкл. таймер
    GIE=1;          //вкл. глобальные прерывания
    lcd_init(0);
    
    while(1)
    {
        __delay_ms(100);
        if((rc_code!=rc_code_old)||(rc_addr=rc_addr_old))// сравниваем старые записанные данных с новыми
        {
            sprintf(str1,"Command: 0x02X",rc_code);
            lcd_printStringXY(2,0,str1);
            sprintf(str1,"Address:0x02X",rc_addr);
            lcd_printStringXY(2,1,str1);
            rc_code_old=rc_code;
            rc_addr_old=rc_addr;
            
        }
    }
}
